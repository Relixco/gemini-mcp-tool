import { promises as fs } from "fs";
import path from "path";
import { BaseTool } from "./base-tool.js";
import { ToolExecutionError } from "../types/errors.js";
import { StandardizedResponseSections } from "../utils/structured-response.js";

/**
 * Simple file-edit tool that performs a literal string replacement.
 * It is intentionally minimal: one file, one search string, one replacement string.
 *
 * This covers the 80% use-case generated by the `analyze-for-changes` and
 * `ask-gemini` tools, where Gemini suggests exact OLD/NEW blocks.
 * If you need multi-file or regex support build on top of this implementation.
 */
class ReplaceTool extends BaseTool {
  name = "replace";
  description = "Replace or delete an exact substring inside a single file on disk. To delete text, use an empty replacement string.";

  constructor() {
    super();
    
    // Configure features - this tool doesn't use Gemini
    this.configureFeatures({
      geminiEnabled: false,
      fileHandling: true,
      promptMode: false,
    });

    // Configure behavior
    this.configureBehavior({
      idempotent: false,
      readsFilesystem: "relative",
      writesFilesystem: true,
      network: "none",
      should_explain: true,
      output_format: "formatted",
      context_needed: true,
      suppress_context: false,
    });
  }

  inputSchema = this.buildInputSchema({
    file_path: {
      type: "string",
      description: "Path to the file that should be modified (relative or absolute).",
    },
    search: {
      type: "string",
      description: "Exact text that must exist in the target file and will be replaced.",
    },
    replace: {
      type: "string",
      description: "Replacement text that will overwrite the matched substring. Use empty string to delete the matched text.",
    },
    occurrences: {
      type: "number",
      description: "Optional: maximum number of occurrences to replace (default: all).",
      default: 0,
    },
  }, ["file_path", "search"]);

  protected async preExecute(args: any): Promise<void> {
    // Validate required fields (file_path and search only)
    this.validateRequired(args, ["file_path", "search"]);
    
    // Replace field is optional and can be empty string for deletions
    // If not provided, default to empty string
    if (args.replace === undefined) {
      args.replace = "";
    }
  }

  protected async doExecute(args: any): Promise<any> {
    const { file_path, search, replace, occurrences = 0 } = args as {
      file_path: string;
      search: string;
      replace: string;
      occurrences?: number;
    };

    const resolvedPath = path.isAbsolute(file_path)
      ? file_path
      : path.join(process.cwd(), file_path);

    // Validate file exists
    let original: string;
    try {
      original = await fs.readFile(resolvedPath, "utf8");
    } catch (err) {
      throw new ToolExecutionError(
        this.name,
        `File not found: ${resolvedPath}`,
        err as Error,
      );
    }

    if (!original.includes(search)) {
      throw new ToolExecutionError(
        this.name,
        `Search string not found in ${resolvedPath}`,
      );
    }

    let updated: string;
    if (occurrences > 0) {
      // Replace only the first N occurrences
      let remaining = occurrences;
      updated = original.replace(new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), (match) => {
        if (remaining === 0) return match;
        remaining -= 1;
        return replace;
      });
    } else {
      // Replace all occurrences
      updated = original.split(search).join(replace);
    }

    await fs.writeFile(resolvedPath, updated, "utf8");

    const replacements = occurrences > 0 ? occurrences : (original.match(new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g")) || []).length;

    // Return structured data for response formatting
    return {
      resolvedPath,
      relativePath: path.relative(process.cwd(), resolvedPath),
      replacements,
      search,
      replace
    };
  }

  protected buildResponseSections(result: any, _args: any): StandardizedResponseSections {
    const { relativePath, replacements, search, replace } = result;
    
    return {
      analysis: `Performed string replacement in file: ${relativePath}\n` +
                `Search string: "${search}"\n` +
                `Replacement string: "${replace}"\n` +
                `Total replacements made: ${replacements}`,
      changesSuggested: `Replaced ${replacements} occurrence(s) of "${search}" with "${replace}"`,
      updatedContent: `✅ Updated ${relativePath} — ${replacements} occurrence(s) replaced.`,
      nextSteps: `Use FileOperations with "read" operation to verify the changes were applied correctly.`
    };
  }

  protected getMetadata(result: any): any {
    return {
      status: "success",
      execution_details: `Replaced ${result.replacements} occurrence(s) in ${result.relativePath}`,
    };
  }
}

// Export behavior for backward compatibility
export const behavior = {
  idempotent: false,
  readsFilesystem: "relative",
  writesFilesystem: true,
  network: "none",
} as const;

// Create and export singleton instance
const replaceTool = new ReplaceTool();
export default replaceTool;